{"version":3,"file":"index.cjs","names":["BaseCheckpointSaver","pendingWrites: CheckpointPendingWrite[]","query: Record<string, unknown>"],"sources":["../src/index.ts"],"sourcesContent":["import { type MongoClient, type Db as MongoDatabase } from \"mongodb\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseCheckpointSaver,\n  type Checkpoint,\n  type CheckpointListOptions,\n  type CheckpointTuple,\n  type SerializerProtocol,\n  type PendingWrite,\n  type CheckpointMetadata,\n  CheckpointPendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\n\nexport type MongoDBSaverParams = {\n  client: MongoClient;\n  dbName?: string;\n  checkpointCollectionName?: string;\n  checkpointWritesCollectionName?: string;\n};\n\n/**\n * A LangGraph checkpoint saver backed by a MongoDB database.\n */\nexport class MongoDBSaver extends BaseCheckpointSaver {\n  protected client: MongoClient;\n\n  protected db: MongoDatabase;\n\n  checkpointCollectionName = \"checkpoints\";\n\n  checkpointWritesCollectionName = \"checkpoint_writes\";\n\n  constructor(\n    {\n      client,\n      dbName,\n      checkpointCollectionName,\n      checkpointWritesCollectionName,\n    }: MongoDBSaverParams,\n    serde?: SerializerProtocol\n  ) {\n    super(serde);\n    this.client = client;\n    this.db = this.client.db(dbName);\n    this.checkpointCollectionName =\n      checkpointCollectionName ?? this.checkpointCollectionName;\n    this.checkpointWritesCollectionName =\n      checkpointWritesCollectionName ?? this.checkpointWritesCollectionName;\n  }\n\n  /**\n   * Retrieves a checkpoint from the MongoDB database based on the\n   * provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with\n   * the matching thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint\n   * for the given thread ID is retrieved.\n   */\n  async getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined> {\n    const {\n      thread_id,\n      checkpoint_ns = \"\",\n      checkpoint_id,\n    } = config.configurable ?? {};\n    let query;\n    if (checkpoint_id) {\n      query = {\n        thread_id,\n        checkpoint_ns,\n        checkpoint_id,\n      };\n    } else {\n      query = { thread_id, checkpoint_ns };\n    }\n    const result = await this.db\n      .collection(this.checkpointCollectionName)\n      .find(query)\n      .sort(\"checkpoint_id\", -1)\n      .limit(1)\n      .toArray();\n    if (result.length === 0) {\n      return undefined;\n    }\n    const doc = result[0];\n    const configurableValues = {\n      thread_id,\n      checkpoint_ns,\n      checkpoint_id: doc.checkpoint_id,\n    };\n    const checkpoint = (await this.serde.loadsTyped(\n      doc.type,\n      doc.checkpoint.value(\"utf8\")\n    )) as Checkpoint;\n    const serializedWrites = await this.db\n      .collection(this.checkpointWritesCollectionName)\n      .find(configurableValues)\n      .toArray();\n    const pendingWrites: CheckpointPendingWrite[] = await Promise.all(\n      serializedWrites.map(async (serializedWrite) => {\n        return [\n          serializedWrite.task_id,\n          serializedWrite.channel,\n          await this.serde.loadsTyped(\n            serializedWrite.type,\n            serializedWrite.value.value(\"utf8\")\n          ),\n        ] as CheckpointPendingWrite;\n      })\n    );\n    return {\n      config: { configurable: configurableValues },\n      checkpoint,\n      pendingWrites,\n      metadata: (await this.serde.loadsTyped(\n        doc.type,\n        doc.metadata.value(\"utf8\")\n      )) as CheckpointMetadata,\n      parentConfig:\n        doc.parent_checkpoint_id != null\n          ? {\n              configurable: {\n                thread_id,\n                checkpoint_ns,\n                checkpoint_id: doc.parent_checkpoint_id,\n              },\n            }\n          : undefined,\n    };\n  }\n\n  /**\n   * Retrieve a list of checkpoint tuples from the MongoDB database based\n   * on the provided config. The checkpoints are ordered by checkpoint ID\n   * in descending order (newest first).\n   */\n  async *list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple> {\n    const { limit, before, filter } = options ?? {};\n    const query: Record<string, unknown> = {};\n\n    if (config?.configurable?.thread_id) {\n      query.thread_id = config.configurable.thread_id;\n    }\n\n    if (\n      config?.configurable?.checkpoint_ns !== undefined &&\n      config?.configurable?.checkpoint_ns !== null\n    ) {\n      query.checkpoint_ns = config.configurable.checkpoint_ns;\n    }\n\n    if (filter) {\n      Object.entries(filter).forEach(([key, value]) => {\n        query[`metadata.${key}`] = value;\n      });\n    }\n\n    if (before) {\n      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };\n    }\n\n    let result = this.db\n      .collection(this.checkpointCollectionName)\n      .find(query)\n      .sort(\"checkpoint_id\", -1);\n\n    if (limit !== undefined) {\n      result = result.limit(limit);\n    }\n\n    for await (const doc of result) {\n      const checkpoint = (await this.serde.loadsTyped(\n        doc.type,\n        doc.checkpoint.value(\"utf8\")\n      )) as Checkpoint;\n      const metadata = (await this.serde.loadsTyped(\n        doc.type,\n        doc.metadata.value(\"utf8\")\n      )) as CheckpointMetadata;\n\n      yield {\n        config: {\n          configurable: {\n            thread_id: doc.thread_id,\n            checkpoint_ns: doc.checkpoint_ns,\n            checkpoint_id: doc.checkpoint_id,\n          },\n        },\n        checkpoint,\n        metadata,\n        parentConfig: doc.parent_checkpoint_id\n          ? {\n              configurable: {\n                thread_id: doc.thread_id,\n                checkpoint_ns: doc.checkpoint_ns,\n                checkpoint_id: doc.parent_checkpoint_id,\n              },\n            }\n          : undefined,\n      };\n    }\n  }\n\n  /**\n   * Saves a checkpoint to the MongoDB database. The checkpoint is associated\n   * with the provided config and its parent config (if any).\n   */\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata\n  ): Promise<RunnableConfig> {\n    const thread_id = config.configurable?.thread_id;\n    const checkpoint_ns = config.configurable?.checkpoint_ns ?? \"\";\n    const checkpoint_id = checkpoint.id;\n    if (thread_id === undefined) {\n      throw new Error(\n        `The provided config must contain a configurable field with a \"thread_id\" field.`\n      );\n    }\n    const [\n      [checkpointType, serializedCheckpoint],\n      [metadataType, serializedMetadata],\n    ] = await Promise.all([\n      this.serde.dumpsTyped(checkpoint),\n      this.serde.dumpsTyped(metadata),\n    ]);\n\n    if (checkpointType !== metadataType) {\n      throw new Error(\"Mismatched checkpoint and metadata types.\");\n    }\n    const doc = {\n      parent_checkpoint_id: config.configurable?.checkpoint_id,\n      type: checkpointType,\n      checkpoint: serializedCheckpoint,\n      metadata: serializedMetadata,\n    };\n    const upsertQuery = {\n      thread_id,\n      checkpoint_ns,\n      checkpoint_id,\n    };\n    await this.db\n      .collection(this.checkpointCollectionName)\n      .updateOne(upsertQuery, { $set: doc }, { upsert: true });\n\n    return {\n      configurable: {\n        thread_id,\n        checkpoint_ns,\n        checkpoint_id,\n      },\n    };\n  }\n\n  /**\n   * Saves intermediate writes associated with a checkpoint to the MongoDB database.\n   */\n  async putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void> {\n    const thread_id = config.configurable?.thread_id;\n    const checkpoint_ns = config.configurable?.checkpoint_ns;\n    const checkpoint_id = config.configurable?.checkpoint_id;\n    if (\n      thread_id === undefined ||\n      checkpoint_ns === undefined ||\n      checkpoint_id === undefined\n    ) {\n      throw new Error(\n        `The provided config must contain a configurable field with \"thread_id\", \"checkpoint_ns\" and \"checkpoint_id\" fields.`\n      );\n    }\n\n    const operations = await Promise.all(\n      writes.map(async ([channel, value], idx) => {\n        const upsertQuery = {\n          thread_id,\n          checkpoint_ns,\n          checkpoint_id,\n          task_id: taskId,\n          idx,\n        };\n\n        const [type, serializedValue] = await this.serde.dumpsTyped(value);\n\n        return {\n          updateOne: {\n            filter: upsertQuery,\n            update: { $set: { channel, type, value: serializedValue } },\n            upsert: true,\n          },\n        };\n      })\n    );\n\n    await this.db\n      .collection(this.checkpointWritesCollectionName)\n      .bulkWrite(operations);\n  }\n\n  async deleteThread(threadId: string) {\n    await this.db\n      .collection(this.checkpointCollectionName)\n      .deleteMany({ thread_id: threadId });\n\n    await this.db\n      .collection(this.checkpointWritesCollectionName)\n      .deleteMany({ thread_id: threadId });\n  }\n}\n"],"mappings":"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"}