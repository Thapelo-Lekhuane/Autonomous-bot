const require_rolldown_runtime = require('./_virtual/rolldown_runtime.cjs');
const __langchain_langgraph_checkpoint = require_rolldown_runtime.__toESM(require("@langchain/langgraph-checkpoint"));

//#region src/index.ts
/**
* A LangGraph checkpoint saver backed by a MongoDB database.
*/
var MongoDBSaver = class extends __langchain_langgraph_checkpoint.BaseCheckpointSaver {
	client;
	db;
	checkpointCollectionName = "checkpoints";
	checkpointWritesCollectionName = "checkpoint_writes";
	constructor({ client, dbName, checkpointCollectionName, checkpointWritesCollectionName }, serde) {
		super(serde);
		this.client = client;
		this.db = this.client.db(dbName);
		this.checkpointCollectionName = checkpointCollectionName ?? this.checkpointCollectionName;
		this.checkpointWritesCollectionName = checkpointWritesCollectionName ?? this.checkpointWritesCollectionName;
	}
	/**
	* Retrieves a checkpoint from the MongoDB database based on the
	* provided config. If the config contains a "checkpoint_id" key, the checkpoint with
	* the matching thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint
	* for the given thread ID is retrieved.
	*/
	async getTuple(config) {
		const { thread_id, checkpoint_ns = "", checkpoint_id } = config.configurable ?? {};
		let query;
		if (checkpoint_id) query = {
			thread_id,
			checkpoint_ns,
			checkpoint_id
		};
		else query = {
			thread_id,
			checkpoint_ns
		};
		const result = await this.db.collection(this.checkpointCollectionName).find(query).sort("checkpoint_id", -1).limit(1).toArray();
		if (result.length === 0) return void 0;
		const doc = result[0];
		const configurableValues = {
			thread_id,
			checkpoint_ns,
			checkpoint_id: doc.checkpoint_id
		};
		const checkpoint = await this.serde.loadsTyped(doc.type, doc.checkpoint.value("utf8"));
		const serializedWrites = await this.db.collection(this.checkpointWritesCollectionName).find(configurableValues).toArray();
		const pendingWrites = await Promise.all(serializedWrites.map(async (serializedWrite) => {
			return [
				serializedWrite.task_id,
				serializedWrite.channel,
				await this.serde.loadsTyped(serializedWrite.type, serializedWrite.value.value("utf8"))
			];
		}));
		return {
			config: { configurable: configurableValues },
			checkpoint,
			pendingWrites,
			metadata: await this.serde.loadsTyped(doc.type, doc.metadata.value("utf8")),
			parentConfig: doc.parent_checkpoint_id != null ? { configurable: {
				thread_id,
				checkpoint_ns,
				checkpoint_id: doc.parent_checkpoint_id
			} } : void 0
		};
	}
	/**
	* Retrieve a list of checkpoint tuples from the MongoDB database based
	* on the provided config. The checkpoints are ordered by checkpoint ID
	* in descending order (newest first).
	*/
	async *list(config, options) {
		const { limit, before, filter } = options ?? {};
		const query = {};
		if (config?.configurable?.thread_id) query.thread_id = config.configurable.thread_id;
		if (config?.configurable?.checkpoint_ns !== void 0 && config?.configurable?.checkpoint_ns !== null) query.checkpoint_ns = config.configurable.checkpoint_ns;
		if (filter) Object.entries(filter).forEach(([key, value]) => {
			query[`metadata.${key}`] = value;
		});
		if (before) query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };
		let result = this.db.collection(this.checkpointCollectionName).find(query).sort("checkpoint_id", -1);
		if (limit !== void 0) result = result.limit(limit);
		for await (const doc of result) {
			const checkpoint = await this.serde.loadsTyped(doc.type, doc.checkpoint.value("utf8"));
			const metadata = await this.serde.loadsTyped(doc.type, doc.metadata.value("utf8"));
			yield {
				config: { configurable: {
					thread_id: doc.thread_id,
					checkpoint_ns: doc.checkpoint_ns,
					checkpoint_id: doc.checkpoint_id
				} },
				checkpoint,
				metadata,
				parentConfig: doc.parent_checkpoint_id ? { configurable: {
					thread_id: doc.thread_id,
					checkpoint_ns: doc.checkpoint_ns,
					checkpoint_id: doc.parent_checkpoint_id
				} } : void 0
			};
		}
	}
	/**
	* Saves a checkpoint to the MongoDB database. The checkpoint is associated
	* with the provided config and its parent config (if any).
	*/
	async put(config, checkpoint, metadata) {
		const thread_id = config.configurable?.thread_id;
		const checkpoint_ns = config.configurable?.checkpoint_ns ?? "";
		const checkpoint_id = checkpoint.id;
		if (thread_id === void 0) throw new Error(`The provided config must contain a configurable field with a "thread_id" field.`);
		const [[checkpointType, serializedCheckpoint], [metadataType, serializedMetadata]] = await Promise.all([this.serde.dumpsTyped(checkpoint), this.serde.dumpsTyped(metadata)]);
		if (checkpointType !== metadataType) throw new Error("Mismatched checkpoint and metadata types.");
		const doc = {
			parent_checkpoint_id: config.configurable?.checkpoint_id,
			type: checkpointType,
			checkpoint: serializedCheckpoint,
			metadata: serializedMetadata
		};
		const upsertQuery = {
			thread_id,
			checkpoint_ns,
			checkpoint_id
		};
		await this.db.collection(this.checkpointCollectionName).updateOne(upsertQuery, { $set: doc }, { upsert: true });
		return { configurable: {
			thread_id,
			checkpoint_ns,
			checkpoint_id
		} };
	}
	/**
	* Saves intermediate writes associated with a checkpoint to the MongoDB database.
	*/
	async putWrites(config, writes, taskId) {
		const thread_id = config.configurable?.thread_id;
		const checkpoint_ns = config.configurable?.checkpoint_ns;
		const checkpoint_id = config.configurable?.checkpoint_id;
		if (thread_id === void 0 || checkpoint_ns === void 0 || checkpoint_id === void 0) throw new Error(`The provided config must contain a configurable field with "thread_id", "checkpoint_ns" and "checkpoint_id" fields.`);
		const operations = await Promise.all(writes.map(async ([channel, value], idx) => {
			const upsertQuery = {
				thread_id,
				checkpoint_ns,
				checkpoint_id,
				task_id: taskId,
				idx
			};
			const [type, serializedValue] = await this.serde.dumpsTyped(value);
			return { updateOne: {
				filter: upsertQuery,
				update: { $set: {
					channel,
					type,
					value: serializedValue
				} },
				upsert: true
			} };
		}));
		await this.db.collection(this.checkpointWritesCollectionName).bulkWrite(operations);
	}
	async deleteThread(threadId) {
		await this.db.collection(this.checkpointCollectionName).deleteMany({ thread_id: threadId });
		await this.db.collection(this.checkpointWritesCollectionName).deleteMany({ thread_id: threadId });
	}
};

//#endregion
exports.MongoDBSaver = MongoDBSaver;
//# sourceMappingURL=index.cjs.map