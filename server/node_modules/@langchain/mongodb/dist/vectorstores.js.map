{"version":3,"file":"vectorstores.js","names":["embeddings: EmbeddingsInterface","args: MongoDBAtlasVectorSearchLibArgs","vectors: number[][]","documents: Document[]","options?: { ids?: string[] }","query: number[]","k: number","filter?: MongoDBAtlasFilter","preFilter: MongoDBDocument | undefined","pipeline: MongoDBDocument[]","query: string","options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>","params: { ids: any[] }","chunkIds: any[][]","texts: string[]","metadatas: object[] | object","dbConfig: MongoDBAtlasVectorSearchLibArgs & { ids?: string[] }","docs: Document[]","array: number[]"],"sources":["../src/vectorstores.ts"],"sourcesContent":["import { type Collection, type Document as MongoDBDocument } from \"mongodb\";\nimport {\n  MaxMarginalRelevanceSearchOptions,\n  VectorStore,\n} from \"@langchain/core/vectorstores\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\nimport { Document } from \"@langchain/core/documents\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\nimport {\n  AsyncCaller,\n  AsyncCallerParams,\n} from \"@langchain/core/utils/async_caller\";\n\n/**\n * Type that defines the arguments required to initialize the\n * MongoDBAtlasVectorSearch class. It includes the MongoDB collection,\n * index name, text key, embedding key, primary key, and overwrite flag.\n *\n * @param collection MongoDB collection to store the vectors.\n * @param indexName A Collections Index Name.\n * @param textKey Corresponds to the plaintext of 'pageContent'.\n * @param embeddingKey Key to store the embedding under.\n * @param primaryKey The Key to use for upserting documents.\n */\nexport interface MongoDBAtlasVectorSearchLibArgs extends AsyncCallerParams {\n  readonly collection: Collection<MongoDBDocument>;\n  readonly indexName?: string;\n  readonly textKey?: string;\n  readonly embeddingKey?: string;\n  readonly primaryKey?: string;\n}\n\n/**\n * Type that defines the filter used in the\n * similaritySearchVectorWithScore and maxMarginalRelevanceSearch methods.\n * It includes pre-filter, post-filter pipeline, and a flag to include\n * embeddings.\n */\ntype MongoDBAtlasFilter = {\n  preFilter?: MongoDBDocument;\n  postFilterPipeline?: MongoDBDocument[];\n  includeEmbeddings?: boolean;\n} & MongoDBDocument;\n\n/**\n * Class that is a wrapper around MongoDB Atlas Vector Search. It is used\n * to store embeddings in MongoDB documents, create a vector search index,\n * and perform K-Nearest Neighbors (KNN) search with an approximate\n * nearest neighbor algorithm.\n */\nexport class MongoDBAtlasVectorSearch extends VectorStore {\n  declare FilterType: MongoDBAtlasFilter;\n\n  private readonly collection: Collection<MongoDBDocument>;\n\n  private readonly indexName: string;\n\n  private readonly textKey: string;\n\n  private readonly embeddingKey: string;\n\n  private readonly primaryKey: string;\n\n  private caller: AsyncCaller;\n\n  _vectorstoreType(): string {\n    return \"mongodb_atlas\";\n  }\n\n  constructor(\n    embeddings: EmbeddingsInterface,\n    args: MongoDBAtlasVectorSearchLibArgs\n  ) {\n    super(embeddings, args);\n    this.collection = args.collection;\n    this.indexName = args.indexName ?? \"default\";\n    this.textKey = args.textKey ?? \"text\";\n    this.embeddingKey = args.embeddingKey ?? \"embedding\";\n    this.primaryKey = args.primaryKey ?? \"_id\";\n    this.caller = new AsyncCaller(args);\n    this.collection.db.client.appendMetadata({\n      name: \"langchainjs_vector\",\n    });\n  }\n\n  /**\n   * Method to add vectors and their corresponding documents to the MongoDB\n   * collection.\n   * @param vectors Vectors to be added.\n   * @param documents Corresponding documents to be added.\n   * @returns Promise that resolves when the vectors and documents have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ) {\n    const docs = vectors.map((embedding, idx) => ({\n      [this.textKey]: documents[idx].pageContent,\n      [this.embeddingKey]: embedding,\n      ...documents[idx].metadata,\n    }));\n    if (options?.ids === undefined) {\n      await this.collection.insertMany(docs);\n    } else {\n      if (options.ids.length !== vectors.length) {\n        throw new Error(\n          `If provided, \"options.ids\" must be an array with the same length as \"vectors\".`\n        );\n      }\n      const { ids } = options;\n      for (let i = 0; i < docs.length; i += 1) {\n        await this.caller.call(async () => {\n          await this.collection.updateOne(\n            { [this.primaryKey]: ids[i] },\n            { $set: { [this.primaryKey]: ids[i], ...docs[i] } },\n            { upsert: true }\n          );\n        });\n      }\n    }\n    return options?.ids ?? docs.map((doc) => doc[this.primaryKey]);\n  }\n\n  /**\n   * Method to add documents to the MongoDB collection. It first converts\n   * the documents to vectors using the embeddings and then calls the\n   * addVectors method.\n   * @param documents Documents to be added.\n   * @returns Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[], options?: { ids?: string[] }) {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Method that performs a similarity search on the vectors stored in the\n   * MongoDB collection. It returns a list of documents and their\n   * corresponding similarity scores.\n   * @param query Query vector for the similarity search.\n   * @param k Number of nearest neighbors to return.\n   * @param filter Optional filter to be applied.\n   * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: MongoDBAtlasFilter\n  ): Promise<[Document, number][]> {\n    const postFilterPipeline = filter?.postFilterPipeline ?? [];\n    const preFilter: MongoDBDocument | undefined =\n      filter?.preFilter ||\n      filter?.postFilterPipeline ||\n      filter?.includeEmbeddings\n        ? filter.preFilter\n        : filter;\n    const removeEmbeddingsPipeline = !filter?.includeEmbeddings\n      ? [\n          {\n            $project: {\n              [this.embeddingKey]: 0,\n            },\n          },\n        ]\n      : [];\n\n    const pipeline: MongoDBDocument[] = [\n      {\n        $vectorSearch: {\n          queryVector: MongoDBAtlasVectorSearch.fixArrayPrecision(query),\n          index: this.indexName,\n          path: this.embeddingKey,\n          limit: k,\n          numCandidates: 10 * k,\n          ...(preFilter && { filter: preFilter }),\n        },\n      },\n      {\n        $set: {\n          score: { $meta: \"vectorSearchScore\" },\n        },\n      },\n      ...removeEmbeddingsPipeline,\n      ...postFilterPipeline,\n    ];\n\n    const results = this.collection\n      .aggregate(pipeline)\n      .map<[Document, number]>((result) => {\n        const { score, [this.textKey]: text, ...metadata } = result;\n        return [new Document({ pageContent: text, metadata }), score];\n      });\n\n    return results.toArray();\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK=20- Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda=0.5 - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {MongoDBAtlasFilter} options.filter - Optional Atlas Search operator to pre-filter on document fields\n   *                                      or post-filter following the knnBeta search.\n   *\n   * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>\n  ): Promise<Document[]> {\n    const { k, fetchK = 20, lambda = 0.5, filter } = options;\n\n    const queryEmbedding = await this.embeddings.embedQuery(query);\n\n    // preserve the original value of includeEmbeddings\n    const includeEmbeddingsFlag = options.filter?.includeEmbeddings || false;\n\n    // update filter to include embeddings, as they will be used in MMR\n    const includeEmbeddingsFilter = {\n      ...filter,\n      includeEmbeddings: true,\n    };\n\n    const resultDocs = await this.similaritySearchVectorWithScore(\n      MongoDBAtlasVectorSearch.fixArrayPrecision(queryEmbedding),\n      fetchK,\n      includeEmbeddingsFilter\n    );\n\n    const embeddingList = resultDocs.map(\n      (doc) => doc[0].metadata[this.embeddingKey]\n    );\n\n    const mmrIndexes = maximalMarginalRelevance(\n      queryEmbedding,\n      embeddingList,\n      lambda,\n      k\n    );\n\n    return mmrIndexes.map((idx) => {\n      const doc = resultDocs[idx][0];\n\n      // remove embeddings if they were not requested originally\n      if (!includeEmbeddingsFlag) {\n        delete doc.metadata[this.embeddingKey];\n      }\n      return doc;\n    });\n  }\n\n  /**\n   * Delete documents from the collection\n   * @param ids - An array of document IDs to be deleted from the collection.\n   *\n   * @returns - A promise that resolves when all documents deleted\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async delete(params: { ids: any[] }): Promise<void> {\n    const CHUNK_SIZE = 50;\n    const chunkIds: any[][] = chunkArray(params.ids, CHUNK_SIZE); // eslint-disable-line @typescript-eslint/no-explicit-any\n    for (const chunk of chunkIds)\n      await this.collection.deleteMany({ _id: { $in: chunk } });\n  }\n\n  /**\n   * Static method to create an instance of MongoDBAtlasVectorSearch from a\n   * list of texts. It first converts the texts to vectors and then adds\n   * them to the MongoDB collection.\n   * @param texts List of texts to be converted to vectors.\n   * @param metadatas Metadata for the texts.\n   * @param embeddings Embeddings to be used for conversion.\n   * @param dbConfig Database configuration for MongoDB Atlas.\n   * @returns Promise that resolves to a new instance of MongoDBAtlasVectorSearch.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: MongoDBAtlasVectorSearchLibArgs & { ids?: string[] }\n  ): Promise<MongoDBAtlasVectorSearch> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create an instance of MongoDBAtlasVectorSearch from a\n   * list of documents. It first converts the documents to vectors and then\n   * adds them to the MongoDB collection.\n   * @param docs List of documents to be converted to vectors.\n   * @param embeddings Embeddings to be used for conversion.\n   * @param dbConfig Database configuration for MongoDB Atlas.\n   * @returns Promise that resolves to a new instance of MongoDBAtlasVectorSearch.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: MongoDBAtlasVectorSearchLibArgs & { ids?: string[] }\n  ): Promise<MongoDBAtlasVectorSearch> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.addDocuments(docs, { ids: dbConfig.ids });\n    return instance;\n  }\n\n  /**\n   * Static method to fix the precision of the array that ensures that\n   * every number in this array is always float when casted to other types.\n   * This is needed since MongoDB Atlas Vector Search does not cast integer\n   * inside vector search to float automatically.\n   * This method shall introduce a hint of error but should be safe to use\n   * since introduced error is very small, only applies to integer numbers\n   * returned by embeddings, and most embeddings shall not have precision\n   * as high as 15 decimal places.\n   * @param array Array of number to be fixed.\n   * @returns\n   */\n  static fixArrayPrecision(array: number[]) {\n    return array.map((value) => {\n      if (Number.isInteger(value)) {\n        return value + 0.000000000000001;\n      }\n      return value;\n    });\n  }\n}\n"],"mappings":"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"}