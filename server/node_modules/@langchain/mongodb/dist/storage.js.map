{"version":3,"file":"storage.js","names":["fields: MongoDBStoreInput","key: string","keys: string[]","keyValuePairs: [string, Uint8Array][]","prefix?: string"],"sources":["../src/storage.ts"],"sourcesContent":["import { BaseStore } from \"@langchain/core/stores\";\nimport { Collection, Document as MongoDocument } from \"mongodb\";\n\n/**\n * Type definition for the input parameters required to initialize an\n * instance of the MongoDBStoreInput class.\n */\nexport interface MongoDBStoreInput {\n  collection: Collection<MongoDocument>;\n  /**\n   * The amount of keys to retrieve per batch when yielding keys.\n   * @default 1000\n   */\n  yieldKeysScanBatchSize?: number;\n  /**\n   * The namespace to use for the keys in the database.\n   */\n  namespace?: string;\n  /**\n   * The primary key to use for the database.\n   * @default \"_id\"\n   */\n  primaryKey?: string;\n}\n\n/**\n * Class that extends the BaseStore class to interact with a MongoDB\n * database. It provides methods for getting, setting, and deleting data,\n * as well as yielding keys from the database.\n * @example\n * ```typescript\n * const client = new MongoClient(process.env.MONGODB_ATLAS_URI);\n * const collection = client.db(\"dbName\").collection(\"collectionName\");\n\n * const store = new MongoDBStore({\n *   collection,\n * });\n *\n * const docs = [\n *   [uuidv4(), \"Dogs are tough.\"],\n *   [uuidv4(), \"Cats are tough.\"],\n * ];\n * const encoder = new TextEncoder();\n * const docsAsKVPairs: Array<[string, Uint8Array]> = docs.map(\n *   (doc) => [doc[0], encoder.encode(doc[1])]\n * );\n * await store.mset(docsAsKVPairs);\n * ```\n */\nexport class MongoDBStore extends BaseStore<string, Uint8Array> {\n  lc_namespace = [\"langchain\", \"storage\", \"mongodb\"];\n\n  collection: Collection<MongoDocument>;\n\n  protected namespace?: string;\n\n  protected yieldKeysScanBatchSize = 1000;\n\n  primaryKey = \"_id\";\n\n  constructor(fields: MongoDBStoreInput) {\n    super(fields);\n    this.collection = fields.collection;\n    this.primaryKey = fields.primaryKey ?? this.primaryKey;\n    this.yieldKeysScanBatchSize =\n      fields.yieldKeysScanBatchSize ?? this.yieldKeysScanBatchSize;\n    this.namespace = fields.namespace;\n    this.collection.db.client.appendMetadata({\n      name: \"langchainjs_storage\",\n    });\n  }\n\n  _getPrefixedKey(key: string) {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return `${this.namespace}${delimiter}${key}`;\n    }\n    return key;\n  }\n\n  _getDeprefixedKey(key: string) {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return key.slice(this.namespace.length + delimiter.length);\n    }\n    return key;\n  }\n\n  /**\n   * Gets multiple keys from the MongoDB database.\n   * @param keys Array of keys to be retrieved.\n   * @returns An array of retrieved values.\n   */\n  async mget(keys: string[]) {\n    const prefixedKeys = keys.map(this._getPrefixedKey.bind(this));\n    const retrievedValues = await this.collection\n      .find({\n        [this.primaryKey]: { $in: prefixedKeys },\n      })\n      .toArray();\n\n    const encoder = new TextEncoder();\n    const valueMap = new Map(\n      retrievedValues.map((item) => [item[this.primaryKey], item])\n    );\n\n    return prefixedKeys.map((prefixedKey) => {\n      const value = valueMap.get(prefixedKey);\n\n      if (!value) {\n        return undefined;\n      }\n\n      if (!(\"value\" in value)) {\n        return undefined;\n      } else if (typeof value.value === \"object\") {\n        return encoder.encode(JSON.stringify(value.value));\n      } else if (typeof value.value === \"string\") {\n        return encoder.encode(value.value);\n      } else {\n        throw new Error(\"Unexpected value type\");\n      }\n    });\n  }\n\n  /**\n   * Sets multiple keys in the MongoDB database.\n   * @param keyValuePairs Array of key-value pairs to be set.\n   * @returns Promise that resolves when all keys have been set.\n   */\n  async mset(keyValuePairs: [string, Uint8Array][]): Promise<void> {\n    const decoder = new TextDecoder();\n\n    const updates = keyValuePairs.map(([key, value]) => {\n      const decodedValue = decoder.decode(value);\n      return [\n        { [this.primaryKey]: this._getPrefixedKey(key) },\n        {\n          $set: {\n            [this.primaryKey]: this._getPrefixedKey(key),\n            ...{ value: decodedValue },\n          },\n        },\n      ];\n    });\n    await this.collection.bulkWrite(\n      updates.map(([filter, update]) => ({\n        updateOne: {\n          filter,\n          update,\n          upsert: true,\n        },\n      }))\n    );\n  }\n\n  /**\n   * Deletes multiple keys from the MongoDB database.\n   * @param keys Array of keys to be deleted.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    const allKeysWithPrefix = keys.map(this._getPrefixedKey.bind(this));\n    await this.collection.deleteMany({\n      [this.primaryKey]: { $in: allKeysWithPrefix },\n    });\n  }\n\n  /**\n   * Yields keys from the MongoDB database.\n   * @param prefix Optional prefix to filter the keys. A wildcard (*) is always appended to the end.\n   * @returns An AsyncGenerator that yields keys from the MongoDB database.\n   */\n  async *yieldKeys(prefix?: string): AsyncGenerator<string> {\n    let regexPattern;\n    if (prefix) {\n      // Convert wildcard (*) to regex equivalent (.*)\n      // Escape special regex characters in prefix to ensure they are treated as literals\n      const escapedPrefix = prefix.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n      const regexPrefix = escapedPrefix.endsWith(\"*\")\n        ? escapedPrefix.slice(0, -1)\n        : escapedPrefix;\n      regexPattern = `^${this._getPrefixedKey(regexPrefix)}.*`;\n    } else {\n      regexPattern = `^${this._getPrefixedKey(\".*\")}`;\n    }\n\n    const cursor = this.collection\n      .find(\n        {\n          [this.primaryKey]: { $regex: regexPattern },\n        },\n        {\n          batchSize: this.yieldKeysScanBatchSize,\n        }\n      )\n      .map((key) => this._getDeprefixedKey(key[this.primaryKey]));\n\n    for await (const document of cursor) {\n      yield document;\n    }\n  }\n}\n"],"mappings":"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"}